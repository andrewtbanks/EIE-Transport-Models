####################################################################
## reaction_sim.py 
## Author: Andy Banks 2019 - University of Kansas Dept. of Geology
#####################################################################
# Code to simulate reactive transport using trajectories generated by advection_dispersion_sim.py
# Instantaneous reaction C1 + C2 -> C3  is simulated with 1:1 stoichiometric and mass ratio
# C1 particles represent treatment solution injected into the aquifer. C2 particles represent contaminated groundwater and C3 particles represent the degradation reaction product. 

# General process:
# - Initially all particles are labeles as either C1 or C2, and assigned a correponding initial mass. 
# - After each timestep, the positions of all particles are grouped spatiall into 0.625 x 0.625 m bins.
# - Within each bin
#       > The total mass carried by C1 and C2 is computed and the limiting reactant is determined.
#       > The mass of the limiting reactant is completely subtracted from particles of the limiting reactant
#       > The mass of the excess reactant is reduced by the same amount
#       > Remaining mass of the excess reactant is distributed evenly among all reamaining excess reactant particles
#       > All particles of the limiting reactant are re-labeled as reaction product (C3), and the total mass reacted is distributed evenly among them.
#       > Mass is conserved, meanaing that all reacted mass (twice the mass of the limiting reactant) is converted into reaction product (C3)

################# Begin Code ###########################

# import python packages
import os
import sys
import numpy as np
import matplotlib.pyplot as plt
import flopy
import flopy.utils.reference  as srf


# load timeseries data output generated by advection_dispersion_sim.py 
path_data = np.load('modpath'+os.sep+'adv_disp_data_case0.npy')

# initialize variables for space and time discretization
ntsteps = len(path_data) # number of timesteps
L = 25 # distance between each pumping well and origin
Ldom = 300.25 # length of the model domain in x and y dirs
xul = -150.125 # left limit of model domain in x direction 
yul = 150.125 # top limit of model domain in y direction

## Build flopy reference grid corresponding to modflow model domain
## Grid is used to identify if particles have been captured by an active well  
nrows = 1201 # number of rows
ncols = 1201 # number of columns 

delr = (Ldom/nrows)*np.ones(nrows) # row spacing
delc = (Ldom/nrows)*np.ones(ncols) # com spacing
mf_ref_grid = srf.SpatialReference(delr = delr, delc = delc, xul = xul, yul = yul) # call flopy to construct reference grid for modflow model
wellX = [0,0,L,-L] # list of x coordinats for wells
wellY = [L,-L,0,0] # list of y coordinats for wells
wellRC = mf_ref_grid.get_rc(wellX,wellY) # get row,col position for each well
wellR = wellRC[0] # row position of each well
wellC = wellRC[1] # col position of each well
# list of indicies indicating the active well at each step (0 = North , 1 = South, 2 = East, 3 = West)
active_well = [3,2,3,2,3,2,1,0,1,0,1,0]

    
## Build flopy reference grid for binning reactants (this gris is coarser than the grid for the modflow domain)
## Reaction is simulated in each cell of this grid
nrows = 480 # number of rows 
ncols = 480 # number of cols 
delr = (Ldom/nrows)*np.ones(nrows) # row spacing (0.625 m) 
delc = (Ldom/nrows)*np.ones(ncols) # col spacing (0.625 m) 
ref_grid = srf.SpatialReference(delr = delr, delc = delc, xul = xul, yul = yul)# call flopy to construct reference grid for reaction 
Xc = ref_grid.xcentergrid # get x coordinate for center of each cell on the grid
Yc = ref_grid.ycentergrid # get y coordinate for center of each cell on the grid


## initalize variables for simulating the reaction
ntreatment = 1961 # number of treatement solution particles (species C1)
ncontaminant = 5884 # number of contaminant solution particles (species C2)
npt = ncontaminant + ntreatment # total number of particles used in the simulation 
treatment_mass = 4 # initial mass assigned to each C1 (treatment) particle
contaminant_mass = 1 # initial mass assigned to each C2 (contaminant) particle
tot_mass = sum(ntreatment*[treatment_mass]  + ncontaminant*[contaminant_mass])# total mass of treatment solution (C1) and contaminant (C2) initially placed in the system

rxn_data = [] # list to store reaction data for particles  after each timestep  
conc_grid_data = [] # (currently inactive - easy to add in later) list to store concentration of each species at each point on the grid after each timestep

############## Main loop ##################

for tstep in np.arange(0,ntsteps):
    #print('---')
    print(tstep) #display current timestep to indicate progress of loop

    
    tot_mass_degraded = 0 # term to store the total mass degreaded at each step - used to check mass balance

    # initialize concentration grid for current timestep - store mass of each species at each point on the grid  
    conc_grid_step = np.zeros([nrows,ncols], dtype=[('mass_c1',float,1),
                                                    ('mass_c2',float,1),
                                                    ('mass_c3',float,1)])

    # initalize array for storing position, mass, species and the plotting color (C1 = yellow, C2 = blue, C3 = green) for each particle used in the simulation
    rxn_step = np.zeros(npt, dtype=[('x', float, 1),
                                    ('y', float, 1),
                                    ('row', float, 1),
                                    ('col', float, 1),
                                    ('species',str, 2),
                                    ('mass',float,1),
                                    ('color',str,10)])

    # get global x,y positions for all particles at the current timestep 
    rxn_step['x'] = path_data[tstep]['x']#  x position (on modflow grid) of all particles at current timestep
    rxn_step['y'] = path_data[tstep]['y']#  y position (on modflow grid) of all particles at current timestep
    
    # get the current species and mass of all particles 
    if tstep ==0: # at t=0 (before any reaction occurs), assign treatment and contaminant their respective initial masses and labels
        rxn_step['species'] = ntreatment*['c1'] + ncontaminant*['c2']
        rxn_step['color']   = ntreatment*['yellow']  + ncontaminant*['blue']
        rxn_step['mass']   = ntreatment*[treatment_mass]  + ncontaminant*[contaminant_mass]
    else: # for t>0, retrieve the current species and mass of all particles from the end of the previous timestep 
        rxn_step['species'] = rxn_data[tstep-1]['species']
        rxn_step['color']   = rxn_data[tstep-1]['color']
        rxn_step['mass']   = rxn_data[tstep-1]['mass']


        
    ## identify and relabel any particles that are extracted from a pumping well during the sequence
    
    # get row,col positions (on modflow grid) for all particles at the current timestep
    rxn_step['row'] = path_data[tstep]['row']#  row position (on modflow grid) of all particles at current timestep
    rxn_step['col'] = path_data[tstep]['col']#  col position (on modflow grid) of all particles at current timestep
    rows = [int(rxn_step['row'][i]) for i in np.arange(0,npt)] # convert to integers
    cols = [int(rxn_step['col'][i]) for i in np.arange(0,npt)] # convert to integers

    
    active_wellR = wellR[active_well[tstep]] # row position (on modflow grid) corresponding to the active well at current timestep 
    active_wellC = wellC[active_well[tstep]] # col position (on modflow grid) corresponding to the active well at current timestep 


    # determine what particles have row,col positions matching those of the active well 
    row_canidates = np.where(rows == active_wellR)[0] # index of particle row positions that match the row position (on modflow grid) of the active well 
    col_canidates = np.where(cols == active_wellC)[0] # index of particle col positions that match the col position (on modflow grid) of the active well 

    local_captured_ind = list(set(row_canidates) & set(col_canidates)) # set of indicies for all row,col particle positions that match the row,col position of the active well

    # relabel particles "extracted" from the pumping well at current timestep as 'ex' and change their plotting color to red
    rxn_step['species'][local_captured_ind]= 'ex' 
    rxn_step['color'][local_captured_ind]= 'red'


    ## Bin particles in reactant grid
    
    #get row,col positions (on reaction grid) for all particles at the current timestep 
    adj_r,adj_c = ref_grid.get_rc(rxn_step['x'],rxn_step['y'])

    rxn_step['row'] = adj_r # row position (on reaction grid) of all particles at current timestep 
    rxn_step['col'] = adj_c # col position (on reaction grid) of all particles at current timestep



    # identify particles labeled as C1 and get row and col positions for each 
    global_c1_ind = np.where(rxn_step['species'] == 'c1')[0] # index for particles labeled C1 at the current timestep
    c1_rows = [int(rxn_step['row'][i]) for i in global_c1_ind] # row position (on reaction grid) of all C1 particles at current timestep 
    c1_cols = [int(rxn_step['col'][i]) for i in global_c1_ind] # col position (on reaction grid) of all C1 particles at current timestep
    c1_rc_pairs = np.transpose(np.array([c1_rows,c1_cols])).tolist() #(npt,2) list of row,col pairs for all C1 particles


    # identify particles labeled as C2 and get row and col positions for each 
    global_c2_ind = np.where(rxn_step['species'] == 'c2')[0]# index for particles labeled C2 at the current timestep
    c2_rows = [int(rxn_step['row'][i]) for i in global_c2_ind]# row position (on reaction grid) of all C2 particles at current timestep 
    c2_cols = [int(rxn_step['col'][i]) for i in global_c2_ind]# col position (on reaction grid) of all C2 particles at current timestep
    c2_rc_pairs = np.transpose(np.array([c2_rows,c2_cols])).tolist() #(npt,2) list of row,col pairs for all C2 particles

    ## For reaction to occur in a given cell, both C1 and C2 particles must be present
    # The next segement of code identifies the row,col position of all cells that contain both C1 and C2 particles 

    # get unique row,col positions for C1 particles
    uniq_c1_rc,c1_rc_inds,c1_rc_inv,c1_rc_counts = np.unique(c1_rc_pairs,axis = 0, return_index = True, return_inverse = True,return_counts = True)# generates index for unique row,col pairs for cells containing C1 particles
    reacting_rc = uniq_c1_rc[np.where(c1_rc_counts>1)[0].tolist()] # retrieve list of unique row,col paris 

    ### loop through each unique row,col pair containing C1 particles
    for reacting_cell in reacting_rc: 

        # get indicies of all C1 particles in current cell
        c1_row_canidate = np.where(np.array(c1_rows) == reacting_cell[0])[0] 
        c1_col_canidate = np.where(np.array(c1_cols) == reacting_cell[1])[0]                           
        local_c1_ind = global_c1_ind[list(set(c1_row_canidate) & set(c1_col_canidate))]

        # get indicies of all C1 particles in current cell
        c2_row_canidate = np.where(np.array(c2_rows) == reacting_cell[0])[0]
        c2_col_canidate = np.where(np.array(c2_cols) == reacting_cell[1])[0]                           
        local_c2_ind = global_c2_ind[list(set(c2_row_canidate) & set(c2_col_canidate))]


        
        # check whether C1 and C2 particles are both present
        local_npt_c1 = len(local_c1_ind) # number of C1 particles in cell
        local_npt_c2 = len(local_c2_ind) # number of C2 particles in cell
        
        check = 1
        if local_npt_c1==0:
            check = 0
        if local_npt_c2==0:
            check = 0

        if check == 1:# if C1 and C2 particles are present in current cell -- proceed with reaction simulation

            # compute mass of each species in the current cell
            local_c1_mass = sum(rxn_step['mass'][local_c1_ind])
            local_c2_mass = sum(rxn_step['mass'][local_c2_ind])

            # to check mass conservation at each step
            initial_reactant_mass = local_c1_mass+local_c2_mass
            remaining_reactant_mass = local_c1_mass+local_c2_mass
            product_mass = 0
            
            # complete reaction step depending on limiting reactant
            # CASE 1 : C2 is the limiting reactant
            if local_c1_mass>local_c2_mass: 
                # determine reacted mass for each species (1:1 stoichiometric and mass ratios here)
                reacted_mass_c1 = local_c2_mass 
                reacted_mass_c2 = local_c2_mass
                
                remaining_mass_c1 = local_c1_mass - local_c2_mass # amount of c1 mass remaining in cell
                converted_mass_c3 = 2*local_c2_mass # amount of c1 mass converted to c3 in cell

                ## redistribute excess c1 mass among  c1 particles
                distributed_mass_c1 = remaining_mass_c1/local_npt_c1 # mass to re-distribute to each c1 particle 
                rxn_step['mass'][local_c1_ind] = distributed_mass_c1

                ## convert limiting reactant particles to c3 and distribute converted mass equally among them
                distributed_mass_c3 = converted_mass_c3/local_npt_c2 # mass to re-distribute to each converted c2->c3 particle 
                rxn_step['species'][local_c2_ind] = 'c3'
                rxn_step['color'][local_c2_ind] = 'green'
                rxn_step['mass'][local_c2_ind] = distributed_mass_c3

                ## update mass conservation variables
                remaining_reactant_mass = remaining_reactant_mass - converted_mass_c3
                product_mass = product_mass + converted_mass_c3


            # CASE 2:  c1 is the limiting reactant
            if local_c2_mass>local_c1_mass: 
                # determine reacted mass for each species (1:1 stoichiometric and mass ratios here)
                reacted_mass_c1 = local_c1_mass 
                reacted_mass_c2 = local_c1_mass
                
                remaining_mass_c2 = local_c2_mass - local_c1_mass # amount of c2 mass remaining in cell
                converted_mass_c3 = 2*local_c1_mass # amount of c1 mass converted to c3 in cell


                ## redistribute excess c2 mass among  c2 particles
                distributed_mass_c2 = remaining_mass_c2/local_npt_c2 # mass to re-distribute to each c1 particle 
                rxn_step['mass'][local_c2_ind] = distributed_mass_c2

                ## convert limiting reactant particles to c3 and distribute converted mass equally among them
                distributed_mass_c3 = converted_mass_c3/local_npt_c1 # mass to re-distribute to each converted c1->c3 particle 
                rxn_step['species'][local_c1_ind] = 'c3'
                rxn_step['color'][local_c1_ind] = 'green'
                rxn_step['mass'][local_c1_ind] = distributed_mass_c3

                ## update mass conservation variables
                remaining_reactant_mass = remaining_reactant_mass - converted_mass_c3
                product_mass = product_mass + converted_mass_c3

            # CASE 3: equal amounts of c1 and c2

            if local_c2_mass==local_c1_mass:

                # all mass is converted to c3
                converted_mass_c3 = local_c1_mass + local_c2_mass
                distributed_mass_c3 = converted_mass_c3/(local_npt_c1 + local_npt_c2)

                # convert all particles in cell to c3 and distribute mass equally among them
                rxn_step['species'][local_c1_ind] = 'c3'
                rxn_step['color'][local_c1_ind] = 'green'
                rxn_step['mass'][local_c1_ind] = distributed_mass_c3

                rxn_step['species'][local_c2_ind] = 'c3'
                rxn_step['color'][local_c2_ind] = 'green'
                rxn_step['mass'][local_c2_ind] = distributed_mass_c3

                ## update mass conservation variables
                remaining_reactant_mass = remaining_reactant_mass - converted_mass_c3
                product_mass = product_mass + converted_mass_c3

        # check mass balance after each timestep and raise error if mass is not conserved
        mass_bal =  initial_reactant_mass - product_mass - remaining_reactant_mass       
        if mass_bal != 0:
            print('MASS NOT CONSERVED')


    # update reaction data list
    rxn_data.append(rxn_step)   
    

# save output to file
np.save('rxn_data_case0',rxn_data) 
    

    


    

    
    

    

    

    


    

    






  






